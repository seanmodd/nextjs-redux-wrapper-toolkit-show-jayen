{"ast":null,"code":"import _regeneratorRuntime from \"/Users/seanmodd/Dev/GitHubYouTube/next-redux-wrapper/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/seanmodd/Dev/GitHubYouTube/next-redux-wrapper/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"/Users/seanmodd/Dev/GitHubYouTube/next-redux-wrapper/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { configureStore, createSlice, ThunkAction } from '@reduxjs/toolkit';\nimport { Action } from 'redux';\nimport { createWrapper, HYDRATE } from 'next-redux-wrapper';\nexport var subjectSlice = createSlice({\n  // name: 'subject',\n  initialState: {},\n  reducers: {\n    setEnt: function setEnt(state, action) {\n      return action.payload;\n    }\n  },\n  extraReducers: _defineProperty({}, HYDRATE, function (state, action) {\n    console.log('HYDRATE', state, action.payload);\n    return _objectSpread(_objectSpread({}, state), action.payload.subject);\n  })\n});\n\nvar makeStore = function makeStore() {\n  return configureStore({\n    reducer: _defineProperty({}, subjectSlice.name, subjectSlice.reducer),\n    devTools: true\n  });\n}; // export type AppStore = ReturnType<typeof makeStore>;\n// export type AppState = ReturnType<AppStore['getState']>;\n// export type AppThunk<ReturnType = void> = ThunkAction<ReturnType, AppState, unknown, Action>;\n\n\nexport var fetchSubject = function fetchSubject(id) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch) {\n      var timeoutPromise;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              timeoutPromise = function timeoutPromise(timeout) {\n                return new Promise(function (resolve) {\n                  return setTimeout(resolve, timeout);\n                });\n              };\n\n              _context.next = 3;\n              return timeoutPromise(200);\n\n            case 3:\n              dispatch(subjectSlice.actions.setEnt(_defineProperty({}, id, {\n                id: id,\n                name: \"Subject \".concat(id)\n              })));\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\nexport var wrapper = createWrapper < AppStore > makeStore;\nexport var selectSubject = function selectSubject(id) {\n  return function (state) {\n    var _state$subjectSlice$n;\n\n    return state === null || state === void 0 ? void 0 : (_state$subjectSlice$n = state[subjectSlice.name]) === null || _state$subjectSlice$n === void 0 ? void 0 : _state$subjectSlice$n[id];\n  };\n};","map":{"version":3,"sources":["/Users/seanmodd/Dev/GitHubYouTube/next-redux-wrapper/store.jsx"],"names":["configureStore","createSlice","ThunkAction","Action","createWrapper","HYDRATE","subjectSlice","initialState","reducers","setEnt","state","action","payload","extraReducers","console","log","subject","makeStore","reducer","name","devTools","fetchSubject","id","dispatch","timeoutPromise","timeout","Promise","resolve","setTimeout","actions","wrapper","AppStore","selectSubject"],"mappings":";;;;;;;;AAAA,SAAQA,cAAR,EAAwBC,WAAxB,EAAqCC,WAArC,QAAuD,kBAAvD;AACA,SAAQC,MAAR,QAAqB,OAArB;AACA,SAAQC,aAAR,EAAuBC,OAAvB,QAAqC,oBAArC;AAEA,OAAO,IAAMC,YAAY,GAAGL,WAAW,CAAC;AACpC;AAEAM,EAAAA,YAAY,EAAE,EAHsB;AAKpCC,EAAAA,QAAQ,EAAE;AACNC,IAAAA,MADM,kBACCC,KADD,EACQC,MADR,EACgB;AAClB,aAAOA,MAAM,CAACC,OAAd;AACH;AAHK,GAL0B;AAWpCC,EAAAA,aAAa,sBACRR,OADQ,EACE,UAACK,KAAD,EAAQC,MAAR,EAAmB;AAC1BG,IAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBL,KAAvB,EAA8BC,MAAM,CAACC,OAArC;AACA,2CACOF,KADP,GAEOC,MAAM,CAACC,OAAP,CAAeI,OAFtB;AAIH,GAPQ;AAXuB,CAAD,CAAhC;;AAsBP,IAAMC,SAAS,GAAG,SAAZA,SAAY;AAAA,SACdjB,cAAc,CAAC;AACXkB,IAAAA,OAAO,sBACFZ,YAAY,CAACa,IADX,EACkBb,YAAY,CAACY,OAD/B,CADI;AAIXE,IAAAA,QAAQ,EAAE;AAJC,GAAD,CADA;AAAA,CAAlB,C,CAQA;AACA;AACA;;;AAEA,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,EAAD;AAAA;AAAA,wEAAQ,iBAAMC,QAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAC1BC,cAAAA,cAD0B,GACT,SAAjBA,cAAiB,CAACC,OAAD;AAAA,uBAAa,IAAIC,OAAJ,CAAY,UAAAC,OAAO;AAAA,yBAAIC,UAAU,CAACD,OAAD,EAAUF,OAAV,CAAd;AAAA,iBAAnB,CAAb;AAAA,eADS;;AAAA;AAAA,qBAG1BD,cAAc,CAAC,GAAD,CAHY;;AAAA;AAKhCD,cAAAA,QAAQ,CACJjB,YAAY,CAACuB,OAAb,CAAqBpB,MAArB,qBACKa,EADL,EACU;AACFA,gBAAAA,EAAE,EAAFA,EADE;AAEFH,gBAAAA,IAAI,oBAAaG,EAAb;AAFF,eADV,EADI,CAAR;;AALgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAR;;AAAA;AAAA;AAAA;AAAA;AAAA,CAArB;AAeP,OAAO,IAAMQ,OAAO,GAAG1B,aAAa,GAAC2B,QAAd,GAAwBd,SAAxC;AAEP,OAAO,IAAMe,aAAa,GAAG,SAAhBA,aAAgB,CAACV,EAAD;AAAA,SAAQ,UAACZ,KAAD;AAAA;;AAAA,WAAWA,KAAX,aAAWA,KAAX,gDAAWA,KAAK,CAAGJ,YAAY,CAACa,IAAhB,CAAhB,0DAAW,sBAA6BG,EAA7B,CAAX;AAAA,GAAR;AAAA,CAAtB","sourcesContent":["import {configureStore, createSlice, ThunkAction} from '@reduxjs/toolkit';\nimport {Action} from 'redux';\nimport {createWrapper, HYDRATE} from 'next-redux-wrapper';\n\nexport const subjectSlice = createSlice({\n    // name: 'subject',\n\n    initialState: {},\n\n    reducers: {\n        setEnt(state, action) {\n            return action.payload;\n        },\n    },\n\n    extraReducers: {\n        [HYDRATE]: (state, action) => {\n            console.log('HYDRATE', state, action.payload);\n            return {\n                ...state,\n                ...action.payload.subject,\n            };\n        },\n    },\n});\n\nconst makeStore = () =>\n    configureStore({\n        reducer: {\n            [subjectSlice.name]: subjectSlice.reducer,\n        },\n        devTools: true,\n    });\n\n// export type AppStore = ReturnType<typeof makeStore>;\n// export type AppState = ReturnType<AppStore['getState']>;\n// export type AppThunk<ReturnType = void> = ThunkAction<ReturnType, AppState, unknown, Action>;\n\nexport const fetchSubject = (id) => async dispatch => {\n    const timeoutPromise = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));\n\n    await timeoutPromise(200);\n\n    dispatch(\n        subjectSlice.actions.setEnt({\n            [id]: {\n                id,\n                name: `Subject ${id}`,\n            },\n        }),\n    );\n};\n\nexport const wrapper = createWrapper<AppStore>(makeStore);\n\nexport const selectSubject = (id) => (state) => state?.[subjectSlice.name]?.[id];\n"]},"metadata":{},"sourceType":"module"}