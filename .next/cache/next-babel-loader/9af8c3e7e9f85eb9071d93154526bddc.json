{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { configureStore, createSlice, ThunkAction } from '@reduxjs/toolkit';\nimport { Action } from 'redux';\nimport { createWrapper, HYDRATE } from 'next-redux-wrapper';\nexport const subjectSlice = createSlice({\n  name: 'subject',\n  initialState: {},\n  reducers: {\n    setEnt(state, action) {\n      return action.payload;\n    }\n\n  },\n  extraReducers: {\n    [HYDRATE]: (state, action) => {\n      console.log('HYDRATE', state, action.payload);\n      return _objectSpread(_objectSpread({}, state), action.payload.subject);\n    }\n  }\n});\n\nconst makeStore = () => configureStore({\n  reducer: {\n    [subjectSlice.name]: subjectSlice.reducer\n  },\n  devTools: true\n}); // export type AppStore = ReturnType<typeof makeStore>;\n// export type AppState = ReturnType<AppStore['getState']>;\n// export type AppThunk<ReturnType = void> = ThunkAction<ReturnType, AppState, unknown, Action>;\n\n\nexport const fetchSubject = id => async dispatch => {\n  const timeoutPromise = timeout => new Promise(resolve => setTimeout(resolve, timeout));\n\n  await timeoutPromise(200);\n  dispatch(subjectSlice.actions.setEnt({\n    [id]: {\n      id,\n      name: `Subject ${id}`\n    }\n  }));\n};\nexport const wrapper = createWrapper < AppStore > makeStore;\nexport const selectSubject = id => state => {\n  var _state$subjectSlice$n;\n\n  return state === null || state === void 0 ? void 0 : (_state$subjectSlice$n = state[subjectSlice.name]) === null || _state$subjectSlice$n === void 0 ? void 0 : _state$subjectSlice$n[id];\n};","map":{"version":3,"sources":["/Users/seanmodd/Dev/GitHubYouTube/next-redux-wrapper/store.jsx"],"names":["configureStore","createSlice","ThunkAction","Action","createWrapper","HYDRATE","subjectSlice","name","initialState","reducers","setEnt","state","action","payload","extraReducers","console","log","subject","makeStore","reducer","devTools","fetchSubject","id","dispatch","timeoutPromise","timeout","Promise","resolve","setTimeout","actions","wrapper","AppStore","selectSubject"],"mappings":";;;;;;AAAA,SAAQA,cAAR,EAAwBC,WAAxB,EAAqCC,WAArC,QAAuD,kBAAvD;AACA,SAAQC,MAAR,QAAqB,OAArB;AACA,SAAQC,aAAR,EAAuBC,OAAvB,QAAqC,oBAArC;AAEA,OAAO,MAAMC,YAAY,GAAGL,WAAW,CAAC;AACpCM,EAAAA,IAAI,EAAE,SAD8B;AAGpCC,EAAAA,YAAY,EAAE,EAHsB;AAKpCC,EAAAA,QAAQ,EAAE;AACNC,IAAAA,MAAM,CAACC,KAAD,EAAQC,MAAR,EAAgB;AAClB,aAAOA,MAAM,CAACC,OAAd;AACH;;AAHK,GAL0B;AAWpCC,EAAAA,aAAa,EAAE;AACX,KAACT,OAAD,GAAW,CAACM,KAAD,EAAQC,MAAR,KAAmB;AAC1BG,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBL,KAAvB,EAA8BC,MAAM,CAACC,OAArC;AACA,6CACOF,KADP,GAEOC,MAAM,CAACC,OAAP,CAAeI,OAFtB;AAIH;AAPU;AAXqB,CAAD,CAAhC;;AAsBP,MAAMC,SAAS,GAAG,MACdlB,cAAc,CAAC;AACXmB,EAAAA,OAAO,EAAE;AACL,KAACb,YAAY,CAACC,IAAd,GAAqBD,YAAY,CAACa;AAD7B,GADE;AAIXC,EAAAA,QAAQ,EAAE;AAJC,CAAD,CADlB,C,CAQA;AACA;AACA;;;AAEA,OAAO,MAAMC,YAAY,GAAIC,EAAD,IAAQ,MAAMC,QAAN,IAAkB;AAClD,QAAMC,cAAc,GAAIC,OAAD,IAAa,IAAIC,OAAJ,CAAYC,OAAO,IAAIC,UAAU,CAACD,OAAD,EAAUF,OAAV,CAAjC,CAApC;;AAEA,QAAMD,cAAc,CAAC,GAAD,CAApB;AAEAD,EAAAA,QAAQ,CACJjB,YAAY,CAACuB,OAAb,CAAqBnB,MAArB,CAA4B;AACxB,KAACY,EAAD,GAAM;AACFA,MAAAA,EADE;AAEFf,MAAAA,IAAI,EAAG,WAAUe,EAAG;AAFlB;AADkB,GAA5B,CADI,CAAR;AAQH,CAbM;AAeP,OAAO,MAAMQ,OAAO,GAAG1B,aAAa,GAAC2B,QAAd,GAAwBb,SAAxC;AAEP,OAAO,MAAMc,aAAa,GAAIV,EAAD,IAASX,KAAD;AAAA;;AAAA,SAAWA,KAAX,aAAWA,KAAX,gDAAWA,KAAK,CAAGL,YAAY,CAACC,IAAhB,CAAhB,0DAAW,sBAA6Be,EAA7B,CAAX;AAAA,CAA9B","sourcesContent":["import {configureStore, createSlice, ThunkAction} from '@reduxjs/toolkit';\nimport {Action} from 'redux';\nimport {createWrapper, HYDRATE} from 'next-redux-wrapper';\n\nexport const subjectSlice = createSlice({\n    name: 'subject',\n\n    initialState: {},\n\n    reducers: {\n        setEnt(state, action) {\n            return action.payload;\n        },\n    },\n\n    extraReducers: {\n        [HYDRATE]: (state, action) => {\n            console.log('HYDRATE', state, action.payload);\n            return {\n                ...state,\n                ...action.payload.subject,\n            };\n        },\n    },\n});\n\nconst makeStore = () =>\n    configureStore({\n        reducer: {\n            [subjectSlice.name]: subjectSlice.reducer,\n        },\n        devTools: true,\n    });\n\n// export type AppStore = ReturnType<typeof makeStore>;\n// export type AppState = ReturnType<AppStore['getState']>;\n// export type AppThunk<ReturnType = void> = ThunkAction<ReturnType, AppState, unknown, Action>;\n\nexport const fetchSubject = (id) => async dispatch => {\n    const timeoutPromise = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));\n\n    await timeoutPromise(200);\n\n    dispatch(\n        subjectSlice.actions.setEnt({\n            [id]: {\n                id,\n                name: `Subject ${id}`,\n            },\n        }),\n    );\n};\n\nexport const wrapper = createWrapper<AppStore>(makeStore);\n\nexport const selectSubject = (id) => (state) => state?.[subjectSlice.name]?.[id];\n"]},"metadata":{},"sourceType":"module"}